# Node Js Backend - Production Setup

- [Node Project](#node-project)
- [Git & Github](#git--github)
- [Husky](#husky)
- [TypeScript](#typescript)
- [Folder Structure](#folder-structure)
- [Commit Lint](#commit-lint)
- [ES Lint](#es-lint)
- [Prettier](#prettier)
- [Project Environment](#project-environment)
- [Express Js](#express-js)
- [Global Error Handler](#global-error-handler)
- [404 Handler](#404-handler)
- [Logger](#logger)
- [Source Map]
- [Colorful Terminal]
- [MongoDB]
- [Database Log Storage]
- [Database Migration]
- [Health Endpoint]
- [Security - Helmet JS]
- [Security - CORS]
- [Security - Rate Limiting]
- [Dependency Updates]
- [Docker]

## Node Project

Initialize a Node.js project:

```bash
npm init -y
```

After that, the package.json file will be created. Replace the test script with start so that you can easily run the server.js file with _npm start_.

```json
   "test": "echo \"Error: no test specified\" && exit 1"
  "start": "node server.js"
```

## Git & Github

Run the following command to initialize Git:

```bash
git init
```

This will create the .git folder in your project. Next, add and commit your files:

```bash
git add .
git commit -am 'feat: Node project setup'
```

Create a repository on GitHub and push your code:

```bash
git remote add origin https://github.com/your-username/your-repo.git
git push origin master
```

Create a `.gitignore` file to exclude files from being pushed to GitHub:

```sh
node_modules
dist
.env
```

## Husky

### About Husky

Husky is a popular tool used in Git repositories to manage and enforce Git hooks. Git hooks are scripts that Git executes before or after events such as committing, pushing, and receiving changes.

Install Husky and lint-staged:

```bash
npm i husky lint-staged -D
```

Initialize Husky:

```bash
npx husky init
```

After this, the .husky folder will be created. Create a pre-commit hook:

## TypeScript

Install TypeScript as a dev dependency:

```bash
npm i typescript -D
```

Initialize TypeScript configuration:

```bash
npx tsc --init
```

In tsconfig.json, enable the following options:

```json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "removeComments": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitAny": true,
    "strictFunctionTypes": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": true,
    "noUnusedParameters": true,
    "noUnusedLocals": true,
    "alwaysStrict": true,
    "noImplicitReturns": true
  }
}
```

Install type definitions for Node.js:

```bash
npm i -D @types/node
```

Install nodemon and ts-node:

```bash
npm i nodemon ts-node -D

```

Add the following scripts to your package.json:

```json
  "scripts": {
  "start": "nodemon src/server.ts",
  "build": "tsc",
  "dev": "nodemon dist/server.js"
}
```

## Folder Structure

First, run the following command in the root directory to create the primary folders:

```sh
mkdir docker logs nginx scripts public test

```

Next, navigate to the src directory and create its subdirectories:

``sh
mkdir -p src/config src/constants src/controllers src/middlewares src/models src/routes src/services src/types src/utils src/views

```

```

### Folder Descriptions

1. docker: Contains Docker-related files and configurations, such as Dockerfiles and docker-compose.yml.
2. logs: Stores log files generated by the application. Helps in debugging and monitoring.
3. nginx: Contains Nginx configuration files if you're using Nginx as a reverse proxy or for static file serving.
4. scripts: Holds utility scripts for tasks like database seeding, backups, or other automation tasks.
5. public: Used for serving static files like images, CSS, and JavaScript to the client.
6. test: Contains test files for unit tests, integration tests, and end-to-end tests.

### src Directory Structure

1. config: Configuration files for the application. This can include database configurations, environment variables, and other setup-related files.
2. constants: Defines constant values used throughout the application, such as status codes, messages, or configuration keys.
3. controllers: Contains the controllers that handle incoming requests and return responses. Controllers coordinate between models and views.
4. middlewares: Middleware functions that process requests before they reach the controllers. Useful for authentication, logging, or error handling.
5. models: Defines the data models or schemas for interacting with the database.
6. routes: Manages the routing of requests to the appropriate controllers.
7. services: Contains business logic and service layer functions. Services interact with models and perform operations needed by controllers.
8. types: Defines TypeScript types and interfaces used throughout the application for type checking and consistency.
9. utils: Utility functions and helpers that can be reused across the application.
10. views: Stores template files or view-related code if using server-side rendering.1.

## Commit Lint

### About

Commit Lint is a tool used to enforce consistent commit message formats in a Git repository. It helps ensure that commit messages follow specified guidelines, which can be particularly useful in maintaining a readable and meaningful commit history.

Install Commit Lint and the conventional config package:

```bash
npm i @commitlint/cli @commitlint/config-conventional -D
```

#### Setup

Create a .husky/commit-msg file to add the commit-msg hook:

```json
#!/user/bin/env sh
. "$(dirname "$0")/_/husky.sh"

npx --no-install commitlint --edit "$1"

```

Create a commitlint.config.js file in the root directory of your project with the following content:

```json

module.exports = {
  extends: ["@commitlint/cli", "@commitlint/config-conventional"],
  rules: {
    "type-enum": [
      2,
      "always",
      [
        "feat",
        "fix",
        "docs",
        "style",
        "refactor",
        "perf",
        "test",
        "build",
        "ci",
        "chore",
        "revert",
      ],
    ],

    "subject-case": [2, "always", "sentence-case"],
  },
};

```

### Commit Message Guidelines

By using this configuration, you should always commit in a proper way. Here are some examples:

- Feature:

```bash
git commit -m "feat: This is a new feature"
```

- Bug Fix:

```bash
git commit -m "fix: This is a bug fix"
```

1. feat: A new feature for the user.
2. fix: A bug fix for the user.
3. docs: Documentation only changes.
4. style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc.).
5. refactor: A code change that neither fixes a bug nor adds a feature.
6. perf: A code change that improves performance.
7. test: Adding missing tests or correcting existing tests.
8. build: Changes that affect the build system or external dependencies.
9. ci: Changes to CI configuration files and scripts.
10. chore: Other changes that don't modify src or test files.
11. revert: Reverts a previous commit.
